{
  "replication_study": {
    "hypothesis": "Respondents classified in the post-secular latent class will be less likely than respondents classified in the traditional latent class to report that 'human beings developed from earlier species of animals' (operationalized as a lower mean of evolved_clean among Post-secular vs Traditional respondents).",
    "study_type": "Observational (cross-sectional survey analysis using processed GSS data)",
    "data_plan": {
      "dataset_identifier": "GSSreplication.dta (Axxe / OSF-derivative cleaned file containing General Social Survey items; located in ./data/original/6/python/replication_data/GSSreplication.dta)",
      "source_type": "Survey (General Social Survey, processed/pool of waves)",
      "wave_or_subset": "Three pre-specified analyses mirroring the .do file: (1) 'not_original' subset: GSS years > 2010; (2) 'all' years available in the provided file; (3) 'original' subset: GSS years <= 2010 (to match the original paper's pooling). See replication_data/OBrienReplication_OSF_Axxe_20201012.do for the same splits.",
      "sample_size": "To be determined exactly at runtime after listwise deletion across the manifest indicators. The original study pooled 2006/2008/2010 with ~2,901 respondents (post_registration.json). The provided processed .dta contains additional years (see the .do for the author's counts per-year comments); expected pooled sample sizes are on the order of a few thousand but exact n will be computed by the Python script before analysis.",
      "unit_of_analysis": "Individual respondents",
      "access_details": "Provided in the repository (./data/original/6/python/replication_data/GSSreplication.dta). The data file included in replication_data appears to be a cleaned/exported GSS subset prepared by the replicator (see OBrienReplication_OSF_Axxe_20201012.do). If re-downloading the raw GSS is needed, GSS access via NORC/ICPSR may have separate access procedures (not required here because the repository includes the processed .dta).",
      "qualification": {
        "explanation": "The provided GSSreplication.dta contains the same manifest items and variables used to construct the latent classes and run the focal test in the original study (.do lists the items: hotcore, radioact, boyorgrl, lasers, electron, viruses, earthsun, condrift, bigbang, evolved, expdesgn, odds1, odds2, scistudy, nextgen, toofast, advfront, scibnfts, bible, reliten, plus wtss and year). The included .do implements the same cleaning and analysis steps (latent class estimation with 2/3/4 classes and t-tests on evolved by Post-secular vs Traditional), so the dataset is qualified to replicate the focal comparison. (See files: ./data/original/6/python/replication_data/OBrienReplication_OSF_Axxe_20201012.do and ./data/original/6/python/post_registration.json.)",
        "similarity_to_original": "High fidelity: The manifest indicators and the focal question 'evolved' are present (see the .do listing and the .dta header). The post_registration.json documents that the original study used GSS pooled waves 2006, 2008, 2010 and manifest indicators including the evolution item; the provided .dta contains those same manifest items and year and weight variables (see ./data/original/6/python/post_registration.json and ./data/original/6/python/replication_data/GSSreplication.dta and the .do file at ./data/original/6/python/replication_data/OBrienReplication_OSF_Axxe_20201012.do).",
        "deviation_from_original": "Deviations that make this a new sample/test: (1) the provided .dta contains additional GSS years (years >2010) so analyses can be run on later data (the replicator explicitly prepares analyses for years>2010, all years, and original-years subsets in the .do); (2) the original LCA was estimated in Mplus (categorical LCA); the provided replication uses the replicator's preprocessed .dta and the provided .do implements LCA via Stata's gsem; my Python translation approximates LCA via sklearn GaussianMixture on numeric-coded manifest indicators (an approximation; see codebase notes). Sources: ./data/original/6/python/post_registration.json and ./data/original/6/python/replication_data/OBrienReplication_OSF_Axxe_20201012.do",
        "citation_of_files": "See ./data/original/6/python/post_registration.json (original study description), ./data/original/6/python/initial_details.txt (focal claim/hypothesis), and ./data/original/6/python/replication_data/OBrienReplication_OSF_Axxe_20201012.do (exact cleaning, manifest list, and planned comparisons)."
      },
      "notes": "Caveats and practical notes: (1) The original LCA used categorical logit formulations (Mplus / Stata gsem). The Python translation uses GaussianMixture on the cleaned numeric manifest variables to approximate class assignment; this is not identical to categorical LCA but preserves workflow (clean items, estimate a finite-mixture model, assign most-likely class, run t-test). (2) The .do file used Stata gsem with sample weights (wtss) and starts/seeds; the Python code attempts to pass sample_weight to GaussianMixture if supported, otherwise fits without weights (not exactly identical to original estimation). (3) All IO in the Python translation uses /app/data paths. For execution, ensure GSSreplication.dta is mounted or copied to /app/data/GSSreplication.dta. (4) The provided .dta file had uppercase variable names; the Python script lowercases column names to match the .do's rename *, lower. (5) Final exact sample sizes will be produced by the script after listwise deletion on the manifest items."
    },
    "planned_method": {
      "steps": [
        "1) Place the supplied GSSreplication.dta at /app/data/GSSreplication.dta (or mount host ./data to /app/data inside the container).",
        "2) Run the Python translation script replication_data/OBrienReplication__py.py (entrypoint). The script lowercases variable names and recodes variables exactly as in the .do (creates *_clean variables).",
        "3) For each pre-specified analysis subset ('not_original' (year>2010), 'all', 'original' (year<=2010)), perform listwise deletion on the manifest cleaned variables.",
        "4) Estimate finite-mixture models with 2, 3, and 4 classes on the cleaned manifest indicators (the original .do runs gsem LCA; the Python script uses GaussianMixture to approximate latent classes), store posterior class probabilities and assign most-likely class.",
        "5) Label classes (using posterior means/manifest profiles) consistent with the .do's approach (author provided labeling heuristics in the .do).",
        "6) Construct PostsecVsTrad indicator (1 = Post-secular class, 0 = Traditional class) depending on the labeling for that subset (the .do labels differ by subset; inspect means to assign labels consistently).",
        "7) Conduct the focal t-test: two-tailed t-test comparing means of evolved_clean between Post-secular and Traditional groups (ttest evolved_clean, by(PostsecVsTrad)).",
        "8) Save class posterior probabilities, assigned classes, t-test results, and a JSON summary to /app/data for inspection and comparison to original reported statistics."
      ],
      "models": "Finite mixture model / latent-class-like model for categorical manifest indicators (original: Stata gsem / Mplus LCA). In Python we implement GaussianMixture (sklearn) as an approximation. After assignment, two-sample t-tests on evolved_clean by class are conducted (scipy.stats.ttest_ind).",
      "outcome_variable": "evolved_clean \u2014 cleaned/coded indicator for the respondent saying humans evolved (constructed per the .do). This is the focal item used in the t-tests.",
      "independent_variables": "Primary independent variable is latent-class membership (categorical: Traditional, Modern, Post-secular). The focal comparison is Post-secular vs Traditional.",
      "control_variables": "The focal SCORE test is an unconditional group comparison (two-sample t-test). For extended analyses, additional sociodemographic controls (race, education, attendance, gender, age, political ideology) can be added in regression models; these are described in post_registration.json and the original paper but are not part of the focal t-test.",
      "tools_software": "Python (entrypoint script), required packages: pandas, numpy, scikit-learn, scipy. Optional: statsmodels for additional analyses, pyreadstat if pandas cannot read the .dta natively in the runtime.",
      "planned_estimation_and_test": {
        "estimation": "Estimate class-specific posterior probabilities and most-likely class assignment; estimate the difference in means of evolved_clean between Post-secular and Traditional groups (difference in proportions/means).",
        "test": "Two-sample two-tailed t-test comparing evolved_clean between Post-secular and Traditional (scipy.stats.ttest_ind; use listwise deletion and, where applicable, compute weighted means or bootstrap if desired). The original .do used ttest with equal-variance default; replication will follow the same unless diagnostics indicate otherwise."
      },
      "missing_data_handling": "Listwise deletion on the pre-specified manifest cleaned variables (exactly as performed in the provided .do: keep observations with rmiss == 0 across vars_clean). Missing values will be coded to NaN and dropped prior to LCA/mixture estimation.",
      "multiple_testing_policy": "The pre-registered focal test is a single comparison (Post-secular vs Traditional on 'evolved'). No multiple-testing correction for the focal test. If multiple pairwise comparisons are reported, apply Bonferroni or report unadjusted p-values with explicit note.",
      "inference_criteria": "Primary significance threshold: two-tailed p < 0.05. Directional expectation: post-secular mean for evolved_clean < traditional mean. Report p-values, test statistics, and effect sizes (difference in means and Cohen's d for binary outcome if requested)."
    },
    "codebase": {
      "files": {
        "replication_data/OBrienReplication__py.py": "Python translation of the provided Stata .do. Implements variable recoding to create *_clean variables (follows the recoding in OBrienReplication_OSF_Axxe_20201012.do), performs listwise deletion, fits GaussianMixture models with k=2,3,4 to the cleaned manifest indicators (approximate LCA), assigns most-likely class (predclass), computes mean item responses by class, runs pairwise t-tests on evolved_clean (focal: Post-secular vs Traditional), and writes results to /app/data/OBrienReplication_summary.json and per-subset classpost/predclass CSVs. This is the entrypoint to run the replication code. It expects /app/data/GSSreplication.dta to exist.",
        "replication_data/GSSreplication.dta": "Processed GSS dataset prepared by the replicator (contains the item-level variables listed in the .do, plus 'year' and 'wtss'). The Python script reads this file (it lowercases variable names) and uses it as the input data for cleaning and analysis.",
        "replication_data/OBrienReplication_OSF_Axxe_20201012.do": "Original Stata .do included for provenance. It documents the exact recoding rules, manifest variable list, subset definitions, and the focal t-tests. The Python script was translated from this file and aims to preserve the cleaning, subset definitions, and testing logic. The .do is not executed but used as reference and provenance."
      },
      "notes": "Notes on code design and execution: (1) The Python script is named OBrienReplication__py.py (double underscore + py) matching the translation naming rules and lives in replication_data. (2) The script reads /app/data/GSSreplication.dta and writes outputs to /app/data (OBrienReplication_summary.json and CSVs). For containerized execution, mount the host repository ./data to /app/data so the script finds the input file. (3) The translation uses GaussianMixture as an approximation to categorical LCA; this is a methodological deviation; results should be interpreted accordingly. (4) The script attempts to use sample_weight when fitting GaussianMixture if the sklearn version supports sample_weight; otherwise it fits without weight. (5) If pandas cannot write Stata format in the runtime, the script will fall back to writing CSVs. (6) The original Stata and Mplus files are retained for provenance, but the only executable file listed here is replication_data/OBrienReplication__py.py."
    },
    "docker_specs": {
      "base_image": "python:3.10-slim",
      "packages": {
        "python": [
          "pandas>=1.4.0",
          "numpy>=1.21.0",
          "scikit-learn>=1.0.0",
          "scipy>=1.7.0",
          "pyreadstat>=1.0.0",
          "statsmodels>=0.13.0"
        ],
        "other": [
          "git",
          "wget",
          "unzip"
        ]
      },
      "hardware": {
        "gpu_support": "false",
        "min_gpu_memory_gb": "0",
        "min_ram_gb": "4"
      },
      "volumes": [
        "./data:/app/data"
      ]
    },
    "analysis": {
      "instructions": "1) Ensure the input file GSSreplication.dta is available at /app/data/GSSreplication.dta (mount ./data to /app/data). 2) From project root (or inside the container), run: python ./data/original/6/python/replication_data/OBrienReplication__py.py. 3) The script will produce /app/data/OBrienReplication_summary.json and CSVs for class posterior/probabilities and predclass per analysis subset. 4) Inspect the JSON for per-subset k=2/3/4 model summaries, per-class means for evolved_clean, and t-test results comparing evolved_clean across classes. 5) The focal comparison is found in the 3-class model output: the t-test comparing evolved_clean for the class labeled Post-secular vs the class labeled Traditional (the .do shows how label assignment was done; confirm labels by inspecting the per-class means).",
      "comparison_metrics": "Compare the replication output to the original paper in the following ways: (1) Difference in mean evolved_clean between Post-secular and Traditional with reported two-tailed p-value (primary focal comparison). (2) Class prevalences (proportion assigned to each class) and whether a Post-secular class of similar prevalence (roughly 20% in original) emerges. (3) Item-response means for 'evolved' within each class (post-secular proportion endorsing evolution vs traditional) and compare absolute differences and direction. (4) Report t-statistics, p-values, and effect sizes (difference in proportions and Cohen's d). (5) If the Python mixture approximation yields materially different class labels or prevalences, document the differences and report sensitivity (e.g., compare with 2/4-class solutions as the .do does)."
    }
  }
}